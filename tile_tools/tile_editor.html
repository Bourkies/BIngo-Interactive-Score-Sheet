<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bingo Board Tile Editor (CSV)</title>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        h1, h2 {
            color: #00aaff;
            text-align: center;
        }
        p {
            text-align: center;
            max-width: 800px;
        }
        .container {
            display: flex;
            flex-direction: column; /* Always stack vertically */
            gap: 20px;
            width: 100%;
            max-width: 1200px; /* Match the controls width */
        }
        .outputs-container {
            display: flex;
            gap: 20px;
            width: 100%;
            align-items: flex-start;
        }
        .editor-panel {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .output-panel {
            width: 100%;
            display: flex;
            flex: 1; /* Allow panels to grow */
            flex-direction: column;
        }
        /* This is now the viewport for panning and zooming */
        #board-container {
            position: relative;
            width: 100%;
            /* REVISED: Removed max-width to fill the new container */
            margin: auto;
            border-radius: 8px;
            overflow: hidden; /* Crucial for panning effect */
            border: 2px solid #444;
            cursor: grab;
        }
        #board-container:active {
            cursor: grabbing;
        }
        /* This new element will be scaled and moved */
        #board-content {
            position: relative;
            width: 100%;
            transform-origin: top left;
            transition: transform 0.1s ease-out;
        }
        #board-image {
            display: block;
            width: 100%;
            height: auto;
        }
        .draggable-tile {
            position: absolute;
            border: 2px solid rgba(255, 255, 255, 0.7);
            background-color: rgba(0, 170, 255, 0.3);
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-sizing: border-box;
            cursor: move;
            touch-action: none;
            user-select: none;
            padding: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer; /* Change cursor to indicate it's clickable */
        }
        #csv-output {
            width: 100%;
            height: 400px; /* Adjusted height slightly */
            font-family: 'Courier New', Courier, monospace;
            background-color: #2d2d2d;
            color: #f0f0f0;
            border: 1px solid #444;
            border-radius: 4px;
            resize: vertical;
            box-sizing: border-box; /* Ensure padding/border is included in width */
        }
        .output-buttons {
            display: flex;
            gap: 10px;
        }
        button {
            background-color: #00aaff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0088cc;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: center;
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            width: 100%;
            max-width: 1200px;
        }
        .file-inputs {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        .file-inputs > div {
            display: flex;
            flex-direction: column;
        }
        .file-inputs label {
            margin-bottom: 5px;
            font-size: 14px;
        }
        .file-inputs input {
            font-size: 14px;
        }
        .zoom-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        /* Details Panel Styles */
        .details-panel {
            width: 100%;
            background-color: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            box-sizing: border-box;
        }
        .details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .details-header h2 {
            margin: 0;
        }
        #add-new-tile-btn {
            margin-top: 0;
            background-color: #28a745;
        }
        #delete-tile-btn {
            margin-top: 0;
            background-color: #dc3545;
        }
        #toggle-global-styles-btn {
            margin-top: 0;
            padding: 5px 10px;
            font-size: 18px;
        }
        #details-form {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }
        .form-field {
            display: flex;
            flex-direction: column;
        }
        .form-field label {
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
        }
        .form-field input, .form-field textarea, .form-field select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            background-color: #1a1a1a;
            color: #f0f0f0;
            border: 1px solid #444;
            border-radius: 4px;
        }
        .form-field textarea {
            resize: vertical;
            min-height: 80px;
            font-family: 'Courier New', Courier, monospace;
        }
        .form-field input:disabled, .form-field textarea:disabled, .form-field select:disabled {
            background-color: #2a2a2a;
            cursor: not-allowed;
            color: #666;
        }
        .overrides-fieldset {
            grid-column: 1 / -1; /* Span all columns */
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px 15px;
        }
        .overrides-fieldset legend {
            color: #00aaff;
        }
        #overrides-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 10px;
        }
        .override-item {
            display: grid;
            grid-template-columns: 1fr 2fr 40px;
            gap: 10px;
            align-items: center;
        }
        #add-override-btn {
            background-color: #007bff;
            width: fit-content;
        }
        #add-override-btn:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #style-preview-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }
        .remove-override-btn {
            background-color: #c0392b;
            padding: 8px;
        }
        .override-item input,
        .override-item select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            background-color: #1a1a1a;
            color: #f0f0f0;
            border: 1px solid #444;
            border-radius: 4px;
        }
        .form-field-compound {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .form-field-compound input[type="color"] {
            padding: 0;
            height: 38px;
            min-width: 38px;
        }
        .form-field-compound input[type="range"] {
            flex-grow: 1;
        }
        .form-field-compound input[type="text"] {
            /* Give text inputs in compound fields a fixed width */
            width: 80px;
        }

    </style>
</head>
<body>
    <h1>Bingo Board Tile Editor</h1>
    <p>Load your CSV and an image of the bingo board. You can drag and resize the tiles, and the new coordinates will be generated in CSV format below. You can then copy this or download it as a file to update your master sheet. You can zoom and pan the board for easier editing.</p>

    <div class="controls">
        <div class="file-inputs">
            <div>
                <label for="csv-file">1. Load Tile Position CSV:</label>
                <input type="file" id="csv-file" accept=".csv">
            </div>
            <div>
                <label for="style-csv-file">2. Load Config &amp; Style CSV:</label>
                <input type="file" id="style-csv-file" accept=".csv">
            </div>
            <div>
                <label for="image-file">3. Load Board Image:</label>
                <input type="file" id="image-file" accept="image/*">
            </div>
        </div>
        <div class="zoom-control">
            <label for="zoom-slider">Zoom:</label>
            <input type="range" id="zoom-slider" min="1" max="5" value="1" step="0.1">
            <span id="zoom-value">100%</span>
            <button id="reset-zoom">Reset</button>
        </div>
    </div>

    <div class="container">
        <div class="editor-panel">
            <div id="style-preview-controls"></div>
            <div id="board-container">
                <div id="board-content">
                    <img id="board-image" src="" alt="Load a background image to see the board" />
                    <!-- Tiles will be injected here -->
                </div>
            </div>
        </div>
        <div id="global-style-editor-box" class="details-panel">
            <div class="details-header">
                <h2>Global Config &amp; Styles</h2>
                <button id="toggle-global-styles-btn" title="Toggle Visibility">-</button>
            </div>
            <form id="global-style-form">
                <p>Load a Style CSV or edit the default values below. Changes will be reflected on the board live.</p>
                <!-- Fieldsets will be generated here -->
            </form>
        </div>
        <div id="tile-editor-box" class="details-panel">
            <div class="details-header">
                <h2>Edit Tile Details</h2>
                <button id="delete-tile-btn" disabled>Delete Selected Tile</button>
                <button id="add-new-tile-btn">Add New Tile</button>
            </div>
            <form id="details-form"></form>
        </div>
        <div class="outputs-container">
            <div class="output-panel">
                <h2>Generated Tile Position CSV</h2>
                <textarea id="csv-output" readonly placeholder="Load a tile position CSV to see the output..."></textarea>
                <div class="output-buttons">
                    <button id="copy-button">Copy Tile CSV</button>
                    <button id="download-button">Download Tile CSV</button>
                </div>
            </div>
            <div class="output-panel">
                <h2>Generated Config &amp; Style CSV</h2>
                <textarea id="style-csv-output" readonly placeholder="Load or edit config &amp; styles to see the output..."></textarea>
                <div class="output-buttons">
                    <button id="copy-style-button">Copy Config CSV</button>
                    <button id="download-style-button">Download Config CSV</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let tilesData = [];
        let csvHeader = [];
        let csvSeparator = ',';
        let newTileCounter = 1;
        let lastSelectedTileIndex = null;
        let currentPreviewStatus = null;
        
        let globalStyles = {
            'Board Image URL': '',
            // Board Config
            'Page Title': 'OSRS Bingo',
            'Max Page Width': '1400px',
            'Show Tile Names': 'false',
            'Unlock on Verified Only': 'false',
            'Show Scoreboard': 'true',
            'Evidence Label': 'Evidence:',
            // Styles
            'Tile Unlocked': '#00aaff', 'Unlocked Opacity': '0.3',
            'Tile Locked': '#333333', 'Locked Opacity': '0.5',
            'Tile Partially Complete': '#f1c40f', 'Partially Complete Opacity': '0.6',
            'Tile Submitted': '#e67e22', 'Submitted Opacity': '0.7',
            'Tile Verified': '#2ecc71', 'Verified Opacity': '0.8',
            'Tile Requires Action': '#e74c3c', 'Requires Action Opacity': '0.8',
            'Default Tile Border Width': '2px', 'Default Tile Border Color': 'rgba(255, 255, 255, 0.7)',
            'Hover Tile Border Color': '#00d9f5', 'Hover Tile Border Width': '3px',
        };

        const STYLE_PROPERTY_GROUPS = {
            'Board Configuration': ['Page Title', 'Board Image URL', 'Max Page Width', 'Show Tile Names', 'Unlock on Verified Only', 'Show Scoreboard', 'Evidence Label'],
            'Status Colors': ['Tile Locked', 'Tile Unlocked', 'Tile Partially Complete', 'Tile Submitted', 'Tile Verified', 'Tile Requires Action'],
            'Status Opacities': ['Locked Opacity', 'Unlocked Opacity', 'Partially Complete Opacity', 'Submitted Opacity', 'Verified Opacity', 'Requires Action Opacity'],
            'Default Tile Styles': ['Default Tile Shape', 'Default Tile Border Width', 'Default Tile Border Color'],
            'Hover Styles': ['Hover Tile Border Width', 'Hover Tile Border Color'],
            'Stamp Images': ['Stamp Image (Locked)', 'Stamp Image (Unlocked)', 'Stamp Image (Partially Complete)', 'Stamp Image (Submitted)', 'Stamp Image (Verified)', 'Stamp Image (Requires Action)'],
            'Stamp Properties': ['Use Stamp by Default', 'Stamp Scale', 'Stamp Rotation', 'Stamp Position'],
        };

        const VALID_OVERRIDE_PROPERTIES = [
            // Tile Status Colors
            'Tile Locked', 'Tile Unlocked', 'Tile Partially Complete', 'Tile Submitted', 'Tile Verified', 'Tile Requires Action',
            // Opacities
            'Locked Opacity', 'Unlocked Opacity', 'Partially Complete Opacity', 'Submitted Opacity', 'Verified Opacity', 'Requires Action Opacity',
            // Default Styles
            'Default Tile Shape', 'Default Tile Border Width', 'Default Tile Border Color',
            // Hover Styles
            'Hover Tile Border Width', 'Hover Tile Border Color',
            // Stamp Usage
            'Use Stamp by Default (Locked)', 'Use Stamp by Default (Unlocked)', 'Use Stamp by Default (Partially Complete)', 'Use Stamp by Default (Submitted)', 'Use Stamp by Default (Verified)', 'Use Stamp by Default (Requires Action)',
            // Stamp Images
            'Stamp Image (Locked)', 'Stamp Image (Unlocked)', 'Stamp Image (Partially Complete)', 'Stamp Image (Submitted)', 'Stamp Image (Verified)', 'Stamp Image (Requires Action)',
            // Stamp Scale
            'Stamp Scale (Locked)', 'Stamp Scale (Unlocked)', 'Stamp Scale (Partially Complete)', 'Stamp Scale (Submitted)', 'Stamp Scale (Verified)', 'Stamp Scale (Requires Action)',
            // Stamp Rotation
            'Stamp Rotation (Locked)', 'Stamp Rotation (Unlocked)', 'Stamp Rotation (Partially Complete)', 'Stamp Rotation (Submitted)', 'Stamp Rotation (Verified)', 'Stamp Rotation (Requires Action)',
            // Stamp Position
            'Stamp Position (Locked)', 'Stamp Position (Unlocked)', 'Stamp Position (Partially Complete)', 'Stamp Position (Submitted)', 'Stamp Position (Verified)', 'Stamp Position (Requires Action)',
        ].sort();

        let currentScale = 1;
        // Store pan coordinates
        let pan = { x: 0, y: 0 };

        const boardContainer = document.getElementById('board-container');
        const boardContent = document.getElementById('board-content'); // The new pannable/zoomable element
        const boardImage = document.getElementById('board-image');
        const csvOutput = document.getElementById('csv-output');
        const csvFileInput = document.getElementById('csv-file');
        const styleCsvFileInput = document.getElementById('style-csv-file');
        const imageFileInput = document.getElementById('image-file');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        const resetZoomBtn = document.getElementById('reset-zoom');
        const copyButton = document.getElementById('copy-button');
        const downloadButton = document.getElementById('download-button');
        const copyStyleButton = document.getElementById('copy-style-button');
        const downloadStyleButton = document.getElementById('download-style-button');
        const detailsPanel = document.getElementById('tile-editor-box');
        const detailsForm = document.getElementById('details-form');
        const addNewTileBtn = document.getElementById('add-new-tile-btn');
        const deleteTileBtn = document.getElementById('delete-tile-btn');
        const toggleGlobalStylesBtn = document.getElementById('toggle-global-styles-btn');

        // A more robust CSV/TSV parser
        function parseCsvLine(line, separator) {
            const values = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i++; // Skip next quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === separator && !inQuotes) {
                    values.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current);
            return values;
        }

        function parseCSV(text) {
            const lines = text.trim().replace(/\r\n/g, '\n').split('\n');
            if (lines.length < 2) return [];
            
            csvSeparator = lines[0].includes('\t') ? '\t' : ',';
            csvHeader = parseCsvLine(lines.shift(), csvSeparator).map(h => h.trim());
            
            return lines.map(line => {
                if (!line.trim()) return null;
                const values = parseCsvLine(line, csvSeparator);
                const row = {};
                csvHeader.forEach((key, index) => {
                    row[key] = values[index] || '';
                });

                // Map to internal format, preserving all original columns
                const internalRow = { ...row };
                internalRow.id = row['TileID'];
                internalRow.x_pct = parseFloat(row['Left (%)']) || 0;
                internalRow.y_pct = parseFloat(row['Top (%)']) || 0;
                internalRow.width_pct = parseFloat(row['Width (%)']) || 0;
                internalRow.height_pct = parseFloat(row['Height (%)']) || 0;
                return internalRow;
            }).filter(Boolean); // Remove empty lines
        }

        csvFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const csvText = e.target.result;
                        tilesData = parseCSV(csvText);
                        if (!csvHeader.includes('TileID') || !csvHeader.includes('Left (%)') || !csvHeader.includes('Top (%)')) {
                            alert('CSV must contain "TileID", "Left (%)", "Top (%)", "Width (%)", and "Height (%)" columns.');
                            return;
                        }
                        createEditorForm(csvHeader);
                        updateEditorPanel(null); // Initialize form in disabled state
                        renderTiles();
                        updateCsvOutput();
                    } catch (err) {
                        alert('Error parsing CSV file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        styleCsvFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const csvText = e.target.result;
                        const parsedStyles = parseStyleCSV(csvText);
                        // Merge loaded styles into existing defaults
                        Object.assign(globalStyles, parsedStyles);
                        populateGlobalStyleEditor();
                        updateStyleCsvOutput();
                        renderTiles();
                    } catch (err) {
                        alert('Error parsing Config & Style CSV file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        imageFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    boardImage.src = e.target.result; // Local file takes precedence
                    // No need to update a config file with the image name anymore
                };
                reader.readAsDataURL(file);
            }
        });

        function renderTiles() {
            boardContent.querySelectorAll('.draggable-tile').forEach(el => el.remove());
            if (!tilesData) return;
            tilesData.forEach((tile, index) => {
                const tileEl = document.createElement('div');
                tileEl.classList.add('draggable-tile');
                if (lastSelectedTileIndex === index) {
                    tileEl.style.borderColor = '#00d9f5'; // Highlight selected tile
                }
                tileEl.dataset.index = index;

                const showTileNames = (globalStyles['Show Tile Names'] || 'false').toLowerCase() === 'true';
                tileEl.textContent = showTileNames ? (tile.Name || tile.id) : tile.id;

                // --- NEW: Dynamic Styling ---
                const status = currentPreviewStatus || 'Unlocked'; // Default to unlocked for preview
                const getProp = (propName) => {
                    if (tile['Overrides (JSON)']) {
                        try {
                            const overrides = JSON.parse(tile['Overrides (JSON)']);
                            if (overrides[propName] !== undefined) return overrides[propName];
                        } catch (e) {}
                    }
                    return globalStyles[propName];
                };

                tileEl.style.left = `${tile.x_pct || 10}%`;
                tileEl.style.top = `${tile.y_pct || 10}%`;
                tileEl.style.width = `${tile.width_pct || 10}%`;
                tileEl.style.height = `${tile.height_pct || 10}%`;
                tileEl.style.transform = `rotate(${tile['Rotation'] || '0deg'})`;

                const color = getProp(`Tile ${status}`) || '#888888';
                const opacity = getProp(`${status} Opacity`) || 0.5;
                tileEl.style.backgroundColor = hexToRgba(color, opacity);

                const borderWidth = getProp('Default Tile Border Width') || '2px';
                const borderColor = getProp('Default Tile Border Color') || 'transparent';
                tileEl.style.border = `${borderWidth} solid ${borderColor}`;

                const shape = (getProp('Default Tile Shape') || 'Square').toLowerCase();
                const clipPaths = { 'ellipse': 'ellipse(50% 50% at 50% 50%)', 'circle': 'ellipse(50% 50% at 50% 50%)', 'diamond': 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)', 'triangle': 'polygon(50% 0%, 0% 100%, 100% 100%)', 'hexagon': 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)' };
                if (clipPaths[shape]) tileEl.style.clipPath = clipPaths[shape];

                tileEl.addEventListener('mouseover', () => {
                    const hoverWidth = getProp('Hover Tile Border Width') || '3px';
                    const hoverColor = getProp('Hover Tile Border Color') || '#00d9f5';
                    tileEl.style.border = `${hoverWidth} solid ${hoverColor}`;
                });
                tileEl.addEventListener('mouseout', () => {
                    tileEl.style.border = `${borderWidth} solid ${borderColor}`;
                });

                boardContent.appendChild(tileEl); // Append to the content div
            });
        }

        function generateCSV(header, data) {
            const headerString = header.join(csvSeparator);
            const rows = data.map(tile => {
                // Map internal format back to CSV format for writing
                const outputTile = { ...tile };
                outputTile['Left (%)'] = (outputTile.x_pct || 0).toFixed(2);
                outputTile['Top (%)'] = (outputTile.y_pct || 0).toFixed(2);
                outputTile['Width (%)'] = (outputTile.width_pct || 0).toFixed(2);
                outputTile['Height (%)'] = (outputTile.height_pct || 0).toFixed(2);

                return header.map(key => {
                    const value = outputTile[key];
                    const stringValue = String(value === undefined || value === null ? '' : value);
                    
                    // Quote if it contains the separator, a quote, or a newline
                    if (stringValue.includes(csvSeparator) || stringValue.includes('"') || stringValue.includes('\n')) {
                        return `"${stringValue.replace(/"/g, '""')}"`;
                    }
                    return stringValue;
                }).join(csvSeparator);
            });
            return [headerString, ...rows].join('\n');
        }

        function updateCsvOutput() {
            if (tilesData.length === 0) return;
            const csvString = generateCSV(csvHeader, tilesData);
            csvOutput.value = csvString;
        }

        function parseStyleCSV(text) {
            const styles = {};
            const lines = text.trim().replace(/\r\n/g, '\n').split('\n');
            const header = lines.shift(); // Assume header is "Property,Value"
            lines.forEach(line => {
                if (!line.trim()) return;
                const parts = parseCsvLine(line, ',');
                if (parts.length >= 2) {
                    const key = parts[0].trim();
                    const value = parts[1].trim();
                    styles[key] = value;
                }
            });
            return styles;
        }

        function generateStyleCSV() {
            const header = 'Property,Value';
            const rows = Object.entries(globalStyles).map(([key, value]) => {
                const keyStr = `"${key.replace(/"/g, '""')}"`;
                const valStr = `"${String(value).replace(/"/g, '""')}"`;
                return `${keyStr},${valStr}`;
            });
            return [header, ...rows].join('\n');
        }

        function updateStyleCsvOutput() {
            const csvString = generateStyleCSV();
            document.getElementById('style-csv-output').value = csvString;
        }


        // NEW: Function to apply the zoom and pan transform
        function applyTransform() {
            boardContent.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${currentScale})`;
        }

        function updateZoom() {
            currentScale = parseFloat(zoomSlider.value);
            zoomValue.textContent = `${Math.round(currentScale * 100)}%`;
            // When zooming, we might need to adjust the pan to keep the image centered
            // For simplicity now, we just apply the transform. A more advanced version could zoom towards the mouse pointer.
            applyTransform();
        }

        zoomSlider.addEventListener('input', updateZoom);

        resetZoomBtn.addEventListener('click', () => {
            zoomSlider.value = 1;
            pan = { x: 0, y: 0 }; // Reset pan on zoom reset
            updateZoom();
        });

        // NEW: Panning logic for the board container
        interact(boardContainer)
            .draggable({
                listeners: {
                    move(event) {
                        pan.x += event.dx;
                        pan.y += event.dy;
                        applyTransform();
                    }
                },
                // Only allow panning when the target is the container or image, not a tile
                allowFrom: '#board-image, #board-container'
            });

        // REVISED: Tile interaction logic to correctly handle zoom
        interact('.draggable-tile')
            .draggable({
                listeners: {
                    move(event) {
                        const target = event.target;
                        const index = target.dataset.index;
                        if (!tilesData[index]) return;

                        const containerWidth = boardContainer.clientWidth;
                        const containerHeight = boardContainer.clientHeight;

                        // Correctly scale the mouse movement by the current zoom level
                        const dx_scaled = event.dx / currentScale;
                        const dy_scaled = event.dy / currentScale;

                        const x_pct = (parseFloat(target.style.left) || 0) + (dx_scaled / containerWidth * 100);
                        const y_pct = (parseFloat(target.style.top) || 0) + (dy_scaled / containerHeight * 100);

                        target.style.left = `${x_pct}%`;
                        target.style.top = `${y_pct}%`;

                        const x_pct_val = parseFloat(x_pct.toFixed(2));
                        const y_pct_val = parseFloat(y_pct.toFixed(2));
                        tilesData[index].x_pct = x_pct_val;
                        tilesData[index].y_pct = y_pct_val;
                        tilesData[index]['Left (%)'] = x_pct_val.toFixed(2);
                        tilesData[index]['Top (%)'] = y_pct_val.toFixed(2);
                        updateEditorPanel(index);
                        
                        requestAnimationFrame(updateCsvOutput);
                    }
                }
            })
            .resizable({
                edges: { left: true, right: true, bottom: true, top: true },
                listeners: {
                    move(event) {
                        const target = event.target;
                        const index = target.dataset.index;
                        if (!tilesData[index]) return;

                        const containerWidth = boardContainer.clientWidth;
                        const containerHeight = boardContainer.clientHeight;

                        let x_pct = parseFloat(target.style.left) || 0;
                        let y_pct = parseFloat(target.style.top) || 0;
                        
                        // event.rect contains the new width/height, which needs to be scaled
                        const width_pct = (event.rect.width / currentScale) / containerWidth * 100;
                        const height_pct = (event.rect.height / currentScale) / containerHeight * 100;

                        // event.deltaRect contains the change in position, also needs scaling
                        x_pct += (event.deltaRect.left / currentScale) / containerWidth * 100;
                        y_pct += (event.deltaRect.top / currentScale) / containerHeight * 100;

                        target.style.width = `${width_pct}%`;
                        target.style.height = `${height_pct}%`;
                        target.style.left = `${x_pct}%`;
                        target.style.top = `${y_pct}%`;
                        
                        const x_pct_val = parseFloat(x_pct.toFixed(2));
                        const y_pct_val = parseFloat(y_pct.toFixed(2));
                        const width_pct_val = parseFloat(width_pct.toFixed(2));
                        const height_pct_val = parseFloat(height_pct.toFixed(2));

                        tilesData[index].x_pct = x_pct_val;
                        tilesData[index].y_pct = y_pct_val;
                        tilesData[index].width_pct = width_pct_val;
                        tilesData[index].height_pct = height_pct_val;
                        tilesData[index]['Left (%)'] = x_pct_val.toFixed(2);
                        tilesData[index]['Top (%)'] = y_pct_val.toFixed(2);
                        tilesData[index]['Width (%)'] = width_pct_val.toFixed(2);
                        tilesData[index]['Height (%)'] = height_pct_val.toFixed(2);
                        updateEditorPanel(index);
                        
                        requestAnimationFrame(updateCsvOutput);
                    }
                }
            });

        copyButton.addEventListener('click', () => {
            if(!csvOutput.value) return;
            csvOutput.select();
            document.execCommand('copy');
            const originalText = copyButton.textContent;
            copyButton.textContent = 'Copied!';
            setTimeout(() => {
                copyButton.textContent = originalText;
            }, 1500);
        });

        downloadButton.addEventListener('click', () => {
            if (!csvOutput.value) return;

            const blob = new Blob([csvOutput.value], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'tile_positions.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        copyStyleButton.addEventListener('click', () => {
            const output = document.getElementById('style-csv-output');
            if(!output.value) return;
            output.select();
            document.execCommand('copy');
            const originalText = copyStyleButton.textContent;
            copyStyleButton.textContent = 'Copied!';
            setTimeout(() => { copyStyleButton.textContent = originalText; }, 1500);
        });

        downloadStyleButton.addEventListener('click', () => {
            const output = document.getElementById('style-csv-output');
            if (!output.value) return;
            const blob = new Blob([output.value], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'tile_styles.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        function hexToRgba(colorStr, alpha) {
            if (!colorStr || typeof colorStr !== 'string') return `rgba(255, 255, 255, ${alpha})`;
            const sColor = colorStr.trim();
            if (sColor === 'transparent') return 'transparent';
            if (!sColor.startsWith('#')) return sColor;
            const hex = sColor.slice(1);
            let r = 0, g = 0, b = 0;
            if (hex.length === 3) { r = parseInt(hex[0] + hex[0], 16); g = parseInt(hex[1] + hex[1], 16); b = parseInt(hex[2] + hex[2], 16); }
            else if (hex.length === 6) { r = parseInt(hex.substring(0, 2), 16); g = parseInt(hex.substring(2, 4), 16); b = parseInt(hex.substring(4, 6), 16); }
            else { return `rgba(255, 255, 255, ${alpha})`; }
            if (isNaN(r) || isNaN(g) || isNaN(b)) return `rgba(255, 255, 255, ${alpha})`;
            return `rgba(${r},${g},${b},${alpha})`;
        }


        // --- Tile Selection & Editor Panel Logic ---

        
        function createEditorForm(header) {
            detailsForm.innerHTML = ''; // Clear previous form
            header.forEach(key => {
                const fieldContainer = document.createElement('div');
                fieldContainer.className = 'form-field';

                const label = document.createElement('label');
                label.htmlFor = `edit-${key.replace(/[^a-zA-Z0-9]/g, '-')}`;
                label.title = key; // Add tooltip with full name
                label.textContent = key;

                // Skip creating a direct field for Overrides (JSON)
                if (key === 'Overrides (JSON)') return;

                const posKeys = ['Left (%)', 'Top (%)', 'Width (%)', 'Height (%)'];
                if (posKeys.includes(key)) {
                    const compound = document.createElement('div');
                    compound.className = 'form-field-compound';
                    const rangeInput = document.createElement('input');
                    rangeInput.type = 'range';
                    rangeInput.min = 0; rangeInput.max = 100; rangeInput.step = 0.01;
                    rangeInput.dataset.sync = key;
                    const textInput = document.createElement('input');
                    textInput.type = 'text';
                    textInput.name = key;
                    textInput.dataset.sync = key;
                    compound.append(rangeInput, textInput);
                    fieldContainer.appendChild(compound);
                } else if (key === 'Rotation') {
                    const compound = document.createElement('div');
                    compound.className = 'form-field-compound';
                    const rangeInput = document.createElement('input');
                    rangeInput.type = 'range';
                    rangeInput.min = 0; rangeInput.max = 360; rangeInput.step = 1;
                    rangeInput.dataset.sync = key;
                    const textInput = document.createElement('input');
                    textInput.type = 'text';
                    textInput.name = key;
                    textInput.dataset.sync = key;
                    compound.append(rangeInput, textInput);
                    fieldContainer.appendChild(compound);
                } else if (key.toLowerCase().includes('description')) {
                    const textarea = document.createElement('textarea');
                    textarea.id = `edit-${key.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    textarea.name = key;
                    textarea.title = key;
                    fieldContainer.appendChild(textarea);
                } else {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.id = `edit-${key.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    input.name = key;
                    input.title = key;
                    fieldContainer.appendChild(input);
                }

                fieldContainer.prepend(label);
                detailsForm.appendChild(fieldContainer);
            });

            // Create a dedicated section for overrides
            const fieldset = document.createElement('fieldset');
            fieldset.className = 'overrides-fieldset';
            const legend = document.createElement('legend');
            legend.textContent = 'Overrides';
            
            const overridesContainer = document.createElement('div');
            overridesContainer.id = 'overrides-container';

            const addOverrideBtn = document.createElement('button');
            addOverrideBtn.type = 'button';
            addOverrideBtn.id = 'add-override-btn';
            addOverrideBtn.textContent = '+ Add Override';
            addOverrideBtn.disabled = true;
            addOverrideBtn.addEventListener('click', () => addOverrideRow());

            fieldset.appendChild(legend);
            fieldset.appendChild(overridesContainer);
            fieldset.appendChild(addOverrideBtn);

            detailsForm.appendChild(fieldset);
        }

        function updateEditorPanel(index) {
            if (index === null || !tilesData[index]) {
                lastSelectedTileIndex = null;
                deleteTileBtn.disabled = true;
                document.getElementById('add-override-btn').disabled = true;
                Array.from(detailsForm.elements).forEach(el => {
                    el.disabled = true;
                    el.value = '';
                });
                return;
            }
            
            lastSelectedTileIndex = index;
            const tile = tilesData[index];

            Array.from(detailsForm.elements).forEach(el => el.disabled = false);
            document.getElementById('add-override-btn').disabled = false;
            deleteTileBtn.disabled = false;

            // Populate the form
            csvHeader.forEach(key => {
                // Skip the raw overrides field
                if (key === 'Overrides (JSON)') return;

                const input = detailsForm.elements[key];
                const syncElements = detailsForm.querySelectorAll(`[data-sync="${key}"]`);
                if (syncElements.length > 0) {
                    const value = tile[key] || '';
                    syncElements.forEach(el => {
                        if (key === 'Rotation' && el.type === 'range') {
                            el.value = parseFloat(value) || 0;
                        } else {
                            el.value = value;
                        }
                    });
                } else if (input) {
                    input.value = tile[key] || '';
                }
            });

            // Populate the overrides section
            let overrides = {};
            try {
                if (tile['Overrides (JSON)']) {
                    overrides = JSON.parse(tile['Overrides (JSON)']);
                }
            } catch (e) { /* Ignore invalid JSON */ }

            // Clear and populate override rows
            document.getElementById('overrides-container').innerHTML = '';
            for (const [key, value] of Object.entries(overrides)) {
                addOverrideRow(key, value);
            }
        }

        function addOverrideRow(key = '', value = '') {
            const container = document.getElementById('overrides-container');
            const item = document.createElement('div');
            item.className = 'override-item';

            const valueContainer = document.createElement('div');
            valueContainer.className = 'override-value-container';

            const keySelect = document.createElement('select');
            keySelect.className = 'override-key';

            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = 'Select a property...';
            keySelect.appendChild(placeholder);

            VALID_OVERRIDE_PROPERTIES.forEach(prop => {
                const option = document.createElement('option');
                option.value = prop;
                option.textContent = prop;
                keySelect.appendChild(option);
            });

            keySelect.value = key;

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-override-btn';
            removeBtn.textContent = '−';

            item.append(keySelect, valueContainer, removeBtn);
            container.appendChild(item);

            keySelect.addEventListener('change', () => {
                populateValueContainer(valueContainer, keySelect.value, '');
                // Manually trigger an input event on the form to update the JSON
                keySelect.dispatchEvent(new Event('input', { bubbles: true }));
            });

            populateValueContainer(valueContainer, key, value);

            removeBtn.addEventListener('click', () => {
                item.remove();
                updateOverridesJsonForCurrentTile();
                renderTiles();
                requestAnimationFrame(updateCsvOutput);
            });
        }

        function populateValueContainer(container, propertyName, value) {
            container.innerHTML = ''; // Clear previous input

            const isColor = propertyName.toLowerCase().includes('color');
            const isOpacity = propertyName.toLowerCase().includes('opacity');
            const isBoolean = propertyName.startsWith('Use Stamp by Default');
            const isShape = propertyName === 'Default Tile Shape';

            if (isColor) {
                const compound = document.createElement('div');
                compound.className = 'form-field-compound';
                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                const textInput = document.createElement('input');
                textInput.type = 'text';
                textInput.className = 'override-value';
                
                colorInput.value = value;
                textInput.value = value;

                colorInput.addEventListener('input', () => { textInput.value = colorInput.value; textInput.dispatchEvent(new Event('input', { bubbles: true })); });
                textInput.addEventListener('input', () => { try { colorInput.value = textInput.value; } catch(e) {} });

                compound.append(colorInput, textInput);
                container.appendChild(compound);
            } else if (isOpacity) {
                const compound = document.createElement('div');
                compound.className = 'form-field-compound';
                const rangeInput = document.createElement('input');
                rangeInput.type = 'range';
                rangeInput.min = 0; rangeInput.max = 1; rangeInput.step = 0.01;
                const textInput = document.createElement('input');
                textInput.type = 'text';
                textInput.className = 'override-value';
                textInput.style.maxWidth = '60px';

                rangeInput.value = value;
                textInput.value = value;

                rangeInput.addEventListener('input', () => { textInput.value = rangeInput.value; textInput.dispatchEvent(new Event('input', { bubbles: true })); });
                textInput.addEventListener('input', () => { rangeInput.value = textInput.value; });

                compound.append(rangeInput, textInput);
                container.appendChild(compound);
            } else if (isBoolean) {
                const select = document.createElement('select');
                select.className = 'override-value';
                ['', 'true', 'false'].forEach(val => {
                    const option = document.createElement('option');
                    option.value = val; option.textContent = val === '' ? 'Default' : val;
                    select.appendChild(option);
                });
                select.value = value;
                container.appendChild(select);
            } else if (isShape) {
                const select = document.createElement('select');
                select.className = 'override-value';
                ['', 'Square', 'Ellipse', 'Circle', 'Diamond', 'Triangle', 'Hexagon'].forEach(shape => {
                    const option = document.createElement('option');
                    option.value = shape; option.textContent = shape === '' ? 'Default' : shape;
                    select.appendChild(option);
                });
                select.value = value;
                container.appendChild(select);
            } else {
                const valueInput = document.createElement('input');
                valueInput.type = 'text';
                valueInput.className = 'override-value';
                valueInput.placeholder = 'Value';
                valueInput.value = value;
                container.appendChild(valueInput);
            }
        }

        function handleEditorInputChange(event) {
            if (lastSelectedTileIndex === null) return;

            const input = event.target;
            // Check if the input is part of an override item
            if (input.closest('.override-item')) {
                updateOverridesJsonForCurrentTile();
                renderTiles(); // Re-render to apply style overrides
            } else {
                updateMainTileData(input);
            }
            
            requestAnimationFrame(updateCsvOutput);
        }

        function updateMainTileData(input) {
            const index = lastSelectedTileIndex;
            if (index === null) return;
            const tile = tilesData[index];
            const key = input.dataset.sync || input.name;
            let value = input.value;

            // Handle Rotation slider specifically to add 'deg'
            if (key === 'Rotation' && input.type === 'range') {
                value = `${value}deg`;
            }

            // If a synced input changes, update the others
            const syncName = input.dataset.sync;
            if (syncName) {
                detailsForm.querySelectorAll(`[data-sync="${syncName}"]`).forEach(el => {
                    if (el !== input) {
                        // When updating the rotation slider from the text input
                        if (syncName === 'Rotation' && el.type === 'range') {
                            el.value = parseFloat(value) || 0;
                        } else {
                            el.value = value;
                        }
                    }
                });
            }
            
            tile[key] = value;

            // If a position/size/ID/Rotation field was changed, update the visual tile
            const tileEl = boardContent.querySelector(`[data-index="${index}"]`);
            if (!tileEl) return;

            if (key === 'TileID') {
                tileEl.textContent = value;
            } else if (key === 'Rotation') {
                tileEl.style.transform = `rotate(${value || '0deg'})`;
            }
            
            const posKeys = {'Left (%)': 'x_pct', 'Top (%)': 'y_pct', 'Width (%)': 'width_pct', 'Height (%)': 'height_pct'};
            if (posKeys[key]) {
                const floatValue = parseFloat(value) || 0;
                tile[posKeys[key]] = floatValue;
                if (key === 'Left (%)') tileEl.style.left = `${floatValue}%`;
                if (key === 'Top (%)') tileEl.style.top = `${floatValue}%`;
                if (key === 'Width (%)') tileEl.style.width = `${floatValue}%`;
                if (key === 'Height (%)') tileEl.style.height = `${floatValue}%`;
            }
        }

        function updateOverridesJsonForCurrentTile() {
            if (lastSelectedTileIndex === null) return;
            const index = lastSelectedTileIndex;

            const overrides = {};
            document.querySelectorAll('#overrides-container .override-item').forEach(item => {
                const key = item.querySelector('.override-key').value;
                const valueInput = item.querySelector('.override-value');
                if (key && valueInput) {
                    let value = valueInput.value;
                    if (value !== '') {
                        if (value === 'true') {
                            overrides[key] = true;
                        } else if (value === 'false') {
                            overrides[key] = false;
                        } else {
                            overrides[key] = value;
                        }
                    }
                }
            });
            if (Object.keys(overrides).length > 0) {
                tilesData[index]['Overrides (JSON)'] = JSON.stringify(overrides);
            } else {
                tilesData[index]['Overrides (JSON)'] = '';
            }
        }

        function addNewTile() {
            const newTile = {};
            csvHeader.forEach(key => newTile[key] = '');

            const newId = `NewTile_${newTileCounter++}`;
            newTile['TileID'] = newId;
            newTile['Name'] = 'New Tile';
            newTile['Left (%)'] = '45.00';
            newTile['Top (%)'] = '45.00';
            newTile['Width (%)'] = '10.00';
            newTile['Height (%)'] = '10.00';

            // Map to internal format
            newTile.id = newId;
            newTile.x_pct = 45.0;
            newTile.y_pct = 45.0;
            newTile.width_pct = 10.0;
            newTile.height_pct = 10.0;

            const newIndex = tilesData.push(newTile) - 1;
            renderTiles(); // Redraws all tiles including the new one
            updateEditorPanel(newIndex); // Selects the new tile
            updateCsvOutput();
        }

        function deleteSelectedTile() {
            if (lastSelectedTileIndex === null) return;
            if (confirm(`Are you sure you want to delete tile "${tilesData[lastSelectedTileIndex].TileID}"?`)) {
                tilesData.splice(lastSelectedTileIndex, 1);
                lastSelectedTileIndex = null;
                renderTiles();
                updateEditorPanel(null); // Explicitly clear the editor panel
                updateCsvOutput();
            }
        }

        detailsForm.addEventListener('input', handleEditorInputChange);
        addNewTileBtn.addEventListener('click', addNewTile);
        deleteTileBtn.addEventListener('click', deleteSelectedTile);
        toggleGlobalStylesBtn.addEventListener('click', toggleGlobalStyles);
        document.getElementById('global-style-form').addEventListener('input', handleGlobalStyleInputChange);

        boardContent.addEventListener('click', (event) => {
            // Don't open modal if the user is dragging/resizing with interact.js
            if (event.target.classList.contains('interact-resizing') || event.target.classList.contains('interact-dragging')) {
                return;
            }
            const tileEl = event.target.closest('.draggable-tile');
            if (tileEl) {
                const index = parseInt(tileEl.dataset.index, 10);
                updateEditorPanel(index);
            }
        });

        function toggleGlobalStyles() {
            const form = document.getElementById('global-style-form');
            const isHidden = form.style.display === 'none';
            form.style.display = isHidden ? '' : 'none';
            toggleGlobalStylesBtn.textContent = isHidden ? '-' : '+';
        }
        // --- Global Style Editor Logic ---
        function createGlobalStyleEditorForm() {
            const form = document.getElementById('global-style-form');
            form.innerHTML = ''; // Clear existing
            Object.entries(STYLE_PROPERTY_GROUPS).forEach(([groupName, properties]) => {
                const fieldset = document.createElement('fieldset');
                fieldset.className = 'overrides-fieldset';
                const legend = document.createElement('legend');
                legend.textContent = groupName;
                fieldset.appendChild(legend);

                properties.forEach(prop => {
                    const fieldContainer = document.createElement('div');
                    fieldContainer.className = 'form-field';
                    const label = document.createElement('label');
                    label.textContent = prop;
                    fieldContainer.appendChild(label);

                    if (prop.toLowerCase().includes('color')) {
                        const compound = document.createElement('div');
                        compound.className = 'form-field-compound';
                        const colorInput = document.createElement('input');
                        colorInput.type = 'color';
                        colorInput.dataset.sync = prop;
                        const textInput = document.createElement('input');
                        textInput.type = 'text';
                        textInput.name = prop;
                        textInput.dataset.sync = prop;
                        compound.append(colorInput, textInput);
                        fieldContainer.appendChild(compound);
                    } else if (prop.toLowerCase().includes('opacity')) {
                        const compound = document.createElement('div');
                        compound.className = 'form-field-compound';
                        const rangeInput = document.createElement('input');
                        rangeInput.type = 'range';
                        rangeInput.min = 0; rangeInput.max = 1; rangeInput.step = 0.01;
                        rangeInput.dataset.sync = prop;
                        const textInput = document.createElement('input');
                        textInput.type = 'text';
                        textInput.name = prop;
                        textInput.dataset.sync = prop;
                        textInput.style.maxWidth = '60px';
                        compound.append(rangeInput, textInput);
                        fieldContainer.appendChild(compound);
                    } else if (prop === 'Default Tile Shape') {
                        const select = document.createElement('select');
                        select.name = prop;
                        ['Square', 'Ellipse', 'Circle', 'Diamond', 'Triangle', 'Hexagon'].forEach(shape => {
                            const option = document.createElement('option');
                            option.value = shape; option.textContent = shape;
                            select.appendChild(option);
                        });
                        fieldContainer.appendChild(select);
                    } else if (['Show Tile Names', 'Unlock on Verified Only', 'Show Scoreboard'].includes(prop)) {
                        const select = document.createElement('select');
                        select.name = prop;
                        ['false', 'true'].forEach(val => {
                            const option = document.createElement('option');
                            option.value = val; option.textContent = val;
                            select.appendChild(option);
                        });
                        fieldContainer.appendChild(select);
                    } else {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.name = prop;
                        fieldContainer.appendChild(input);
                    }
                    fieldset.appendChild(fieldContainer);
                });
                form.appendChild(fieldset);
            });
        }


        function populateGlobalStyleEditor() {
            const form = document.getElementById('global-style-form');
            for (const [key, value] of Object.entries(globalStyles)) {
                // Handle compound fields
                const syncElements = form.querySelectorAll(`[data-sync="${key}"]`);
                if (syncElements.length > 0) {
                    syncElements.forEach(el => el.value = value);
                } else if (form.elements[key]) { // Handle simple fields
                    form.elements[key].value = value;
                }

            }
        }

        function handleGlobalStyleInputChange(event) {
            const input = event.target;
            const syncName = input.dataset.sync;

            if (syncName) {
                // Update other synced inputs
                document.querySelectorAll(`[data-sync="${syncName}"]`).forEach(el => {
                    if (el !== input) el.value = input.value;
                });
                globalStyles[syncName] = input.value;
            } else {
                globalStyles[input.name] = input.value;
            }

            if (input.name === 'Board Image URL') {
                boardImage.src = input.value;
            }

            updateStyleCsvOutput();
            renderTiles();
        }

        // --- Style Preview Logic ---
        function createStylePreviewButtons() {
            const container = document.getElementById('style-preview-controls');
            const statuses = ['Locked', 'Unlocked', 'Partially Complete', 'Submitted', 'Verified', 'Requires Action', null];
            statuses.forEach(status => {
                const btn = document.createElement('button');
                btn.textContent = status || 'Clear Preview';
                btn.onclick = () => {
                    currentPreviewStatus = status;
                    container.querySelectorAll('button').forEach(b => b.style.backgroundColor = '');
                    if (status) btn.style.backgroundColor = '#0088cc';
                    renderTiles();
                };
                container.appendChild(btn);
            });
        }

        createGlobalStyleEditorForm();
        populateGlobalStyleEditor();
        updateStyleCsvOutput();
        createStylePreviewButtons();
    </script>
</body>
</html>